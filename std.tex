\documentclass{article}

\usepackage{xcolor}
\usepackage{float}
\usepackage{ulem}

\usepackage{backnaur}
\usepackage{hyperref}
\usepackage{fancyvrb}


\author{Deducteam}
\title{Dedukti}
\date{\today}

\begin{document}
\maketitle

\section{Syntax}

\paragraph{Comments}

\DefineShortVerb{\|}
Comments are multi line, opened by |(;| and closed by |;)|. There may be nested comments,
|(; foo (; bar ;) baz ;)| is correct.
\UndefineShortVerb{\|}

\paragraph{Characters}

The standard characters for the language are defined by
\href{https://www.unicode.org/reports/tr31/tr31-33.html}{Unicode standard annex 31}\footnote{also used by Rust}.

We define the classes of identifiers and qualified identifiers,

\begin{bnf*}
	\bnfprod{id}{\bnftd{annex 31}}\\
	\bnfmore{\bnfts{\{|} \bnftd{anything but pipe brace} \bnfts{|\}}}\\
	\bnfprod{mid}{\bnfpn{id}}\\
	\bnfprod{qid}{\bnfpn{id} \bnfts{.} \bnfpn{id}}\\
\end{bnf*}

Escaped identifiers \verb+{|foo space|}+ ought to accept anything as identifier but the string
\verb+|}+. \verb+{|foo|}+ is the same as \verb+foo+, but \verb+{|fo o|}+ is no the same as \verb+fo o+.

\subsection{Terms}

\paragraph{Option 1: legacy terms}

Legacy Dedukti, no primitive ``let-in'' construction. Non dependent products allowed.
Type annotations for abstractions mandatory.
\begin{bnf*}
	\bnfprod{t}{\bnfts{TYPE} \bnfor \bnfpn{qid} \bnfor \bnfpn{t} \bnfpn{t} \bnfor
		\bnfts{(} \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{)}\bnfsp \bnfts{->}\bnfsp \bnfpn{t} \bnfor
		\bnfpn{t} \bnfsp \bnfts{->} \bnfsp \bnfpn{t}
	}\\
	\bnfmore{
		\bnfts{(} \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{)} \bnfsp \bnfts{=>} \bnfsp \bnfpn{t} \bnfor
		\bnfts{(} \bnfpn{t} \bnfts{)}
	}
\end{bnf*}

\paragraph{Option 2: Twelf-style terms}
\begin{bnf*}
	\bnfprod{t}{\bnfts{TYPE} \bnfor \bnfpn{qid} \bnfor \bnfpn{t} \bnfpn{t} \bnfor
		\bnfts{\{} \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{\}}\bnfsp \bnfpn{t} \bnfor
		\bnfpn{t} \bnfsp \bnfts{->} \bnfsp \bnfpn{t} \bnfor
	}\\
	\bnfmore{\bnfts{[} \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{]} \bnfsp \bnfpn{t} \bnfor \bnfts{(} \bnfpn{t} \bnfts{)}}
\end{bnf*}
Where abstractions are written ``\verb+[x : A] e+'' and dependent products ``\verb+{x: A} B+''.

\subsection{Commands}

\paragraph{Rewrite rules}

Legacy Dedukti syntax.

\begin{bnf*}
	\bnfprod{lctxt}{\bnfes \bnfor \bnfpn{id} \bnfts{,} \bnfsp \bnfpn{lctxt}}\\
    \bnfprod{rule}{\bnfts{[} \bnfpn{lctxt} \bnfts{]} \bnfpn{t} \bnfsp \bnfts{-->} \bnfsp \bnfpn{t}}\\
    \bnfprod{rules}{\bnfpn{rule}{+} \bnfts{.}}
\end{bnf*}

\paragraph{Symbol declarations}
\begin{bnf*}
    \bnfprod{visibility}{\bnfts{private} \bnfor \bnfts{protected}}\\
    \bnfprod{statement}{\bnfpn{visibility}? \bnfsp \bnfts{constant} \bnfsp \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{.}}\\
    \bnfmore{\bnfpn{visibility}? \bnfsp \bnfts{injective}? \bnfsp \bnfts{symbol} \bnfsp \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{.}}\\
    \bnfmore{\bnfpn{visibility}? \bnfsp \bnfts{definition} \bnfsp \bnfpn{id} \bnfsp (\bnfts{:} \bnfsp \bnfpn{t})? \bnfsp \bnfts{:=} \bnfpn{t} \bnfts{.}}
\end{bnf*}

Opacity is left as a pragma.

\paragraph{Module declaration}
\begin{bnf*}
    \bnfprod{fname}{\bnfts{"} \bnftd{unix filename} \bnfts{"}}\\
    \bnfprod{mod-decl}{\bnfts{module} \bnfsp \bnfpn{mid} \bnfsp (\bnfts{with} \bnfsp \bnfpn{mid}{+})? \bnfts{.}}
\end{bnf*}

Semantic-wise,

\verb|module Foo with Bar Baz.|
creates a module \verb+Foo+ using modules \verb|Bar| and \verb|Baz|.
The location of the source files where \verb|Bar| and \verb|Baz| are found is
left unspecified.
A qualified identifier \verb|Frobz.x| is valid only if \verb|Frobz| is listed
in the imported modules.

There can be several modules per files.
A module cannot refer to a module defined later in the
file\footnote{easier to compile}.

\subsection{Assertions}

Three primitive judgements
\begin{bnf*}
	\bnfprod{tctxt}{\bnfes \bnfor \bnfpn{id} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{,} \bnfsp \bnfpn{tctxt}}\\
	\bnfprod{assertion}{\bnfts{assert} \bnfsp \bnfpn{tctxt} \bnfsp \bnfts{|-} \bnfsp \bnfpn{t}} \bnfts{.}\\
	\bnfmore{\bnfts{assert} \bnfsp \bnfpn{tctxt} \bnfsp \bnfts{|-} \bnfsp \bnfpn{t} \bnfsp \bnfts{:} \bnfsp \bnfpn{t} \bnfts{.}}\\
	\bnfmore{\bnfts{assert} \bnfsp \bnfpn{tctxt} \bnfsp \bnfts{|-} \bnfsp \bnfpn{t} \bnfsp \bnfts{==} \bnfsp \bnfpn{t} \bnfts{.}}
\end{bnf*}
that encode typability (inference), type checking and convertibility.

\subsection{Pragma}

Compiler specific instructions. Any pragma may be ignored safely. Pragmas are comments with a particular syntax.

\begin{bnf*}
	\bnfprod{pragma}{\bnfts{(;\#} \bnfsp \bnftd{name} \bnfsp \bnftd{params}{+} \bnfsp \bnfts{\#;)}}
\end{bnf*}

\end{document}
% vim: tabstop=2 shiftwidth=2
